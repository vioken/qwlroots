// Copyright (C) 2022 JiDe Zhang <zccrs@live.com>.
// SPDX-License-Identifier: Apache-2.0 OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only

#pragma once

#include <qwglobal.h>
#include <QObject>

struct wlr_ABC;

QW_BEGIN_NAMESPACE

class QWABCPrivate;
class QW_EXPORT QWABC : public QObject, public QWObject
{
    QW_DECLARE_PRIVATE(QWABC)
public:
    explicit QWABC(wlr_ABC *handle);

    inline wlr_ABC *handle() const {
        return QWObject::handle<wlr_ABC>();
    }
};

QW_END_NAMESPACE

// Copyright (C) 2022 JiDe Zhang <zccrs@live.com>.
// SPDX-License-Identifier: Apache-2.0 OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only

#include "qwabc.h"
#include "util/qwsignalconnector.h"

extern "C" {
#include <wlr/types/wlr_abc.h>
}

QW_BEGIN_NAMESPACE

class QWABCPrivate : public QWObjectPrivate
{
public:
    QWABCPrivate(wlr_ABC *handle, QWABC *qq)
        : QWObjectPrivate(handle, qq)
    {
        sc.connect(&handle->events.destroy, this, &QWABCPrivate::on_destroy);
    }
    ~QWABCPrivate() {
        sc.invalidate();
        if (m_handle)
            wlr_ABC_destroy(q_func()->handle());
    }

    void on_destroy(void *);

    QW_DECLARE_PUBLIC(QWABC)
    QWSignalConnector sc;
};

void QWABCPrivate::on_destroy(void *)
{
    m_handle = nullptr;
    q_func()->deleteLater();
}

QWABC::QWABC(wlr_ABC *handle)
    : QObject(nullptr)
    , QWObject(*new QWABCPrivate(handle, this))
{

}

QW_END_NAMESPACE
